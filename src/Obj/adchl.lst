C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ADCHL
OBJECT MODULE PLACED IN .\Obj\adchl.obj
COMPILER INVOKED BY: D:\Keil\C51\BIN\C51.EXE app\adchl.c LARGE OMF2 WARNINGLEVEL(0) BROWSE ORDER INCDIR(.\app;.\Lib;.\bs
                    -p) DEBUG PRINT(.\Obj\adchl.lst) OBJECT(.\Obj\adchl.obj)

line level    source

   1          /*************************************************
   2            Copyright (C), RoadLighting Tech. Co., Ltd.
   3            File name: flash.c     
   4            Author: George      Version: 1.0        Date: 2015/08/20
   5            Description:  Flashæ“ä½œ
   6            Others: æ—         
   7            Function List:  
   8              1. flash_page_erase
   9                  2. flash_write_data
  10                  3. flash_read_data
  11                  4. flash_write_byte
  12                  5. flash_read_byte
  13            History:                            
  14              1. Date:
  15                 Author:
  16                 Modification:
  17          *************************************************/
  18          #include "adchl.h"
  19          #include "adc.h"
  20          #include "com.h"
  21          #include "code_swtich.h"
  22          #include "rn8209d.h"
  23          #include "bsp.h"
  24          #include "USART.h"
  25          #include "EEPROM.h"
  26          #include "timerhl.h"
  27          #include "eepromhl.h"
  28          
  29          
  30          extern u32 time_lamp_on_sec[4], time_lamp_off_sec[4], time_reset_hour;
  31          extern u32 time_saving_sec;
  32          extern u32 time_lamp_on_checking_sec[4];
  33          extern u32 time_lamp_off_checking_sec[4];
  34          extern u8 work_mode;
  35          
  36          u8 g_alarm_signal[4] = {0};
  37          static u8 g_status_new[4] = {0}, g_status_old[4] = {0}; 
  38          static u8 g_power_on_flag[4] = {0};
  39          static u8 g_write_sector1_en_flag[4] = {0}, g_write_sector2_en_flag[4] = {0};
  40          u32 g_curr_old[4] = {0}, g_curr_new[4] = {0}, g_curr_tmp[4] = {0};
  41          u8 g_power_switch_flag[4] = {0};
  42          
  43          u32 g_unusual_curr[4] = {0};
  44          u8 g_unusual_flag[4] = {0};
  45          
  46          Queue *g_queue[4];
  47          u8 saving_flag = 0;
  48          
  49          /*
  50          *Function: get_adc_val      
  51          *Description: æ— ç”µæ—¶é‡‡é›†adå€¼  
  52          *Calls:  æ— 
  53          *Data Accessed: æ—   
  54          *Data Updated: æ—     
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 2   

  55          *Input: 
  56                  channelï¼šé€šé“å·
  57          *Output: æ—  
  58          *Return: é‡‡é›†åˆ°çš„adå€¼        
  59          *Others: æ—   
  60          */
  61          u16 get_adc_val(u8 channel)
  62          {
  63   1              u16 adc_val = 0, adc_tmp[10] = {0}, i = 0;
  64   1              u32 tmp = 0;
  65   1              for (i=0; i<10; i++)
  66   1              {
  67   2                      adc_val = Get_ADC10bitResult(channel);
  68   2                      tmp += adc_val;
  69   2              }
  70   1      
  71   1              adc_val = tmp / 10;
  72   1              
  73   1              return adc_val;
  74   1      }
  75          
  76          
  77          /*
  78          *Function: set_channel      
  79          *Description: è®¾ç½®é€šé“  
  80          *Calls: 
  81                  set_port_val
  82          *Data Accessed: æ—   
  83          *Data Updated: æ—     
  84          *Input: 
  85                  channelï¼šé€šé“å·
  86          *Output: æ—  
  87          *Return: æ—         
  88          *Others: æ—   
  89          */
  90          void set_channel(u8 channel)
  91          {
  92   1              switch (channel)
  93   1              {
  94   2                      case 0:
  95   2                              set_port_val(CH_CTRL0, 0);
  96   2                              set_port_val(CH_CTRL1, 0);
  97   2                      break;
  98   2                      
  99   2                      case 1:
 100   2                              set_port_val(CH_CTRL0, 1);
 101   2                              set_port_val(CH_CTRL1, 0);
 102   2                      break;
 103   2                      
 104   2                      case 2:
 105   2                              set_port_val(CH_CTRL0, 0);
 106   2                              set_port_val(CH_CTRL1, 1);
 107   2                      break;
 108   2                      
 109   2                      case 3:
 110   2                              set_port_val(CH_CTRL0, 1);
 111   2                              set_port_val(CH_CTRL1, 1);
 112   2                      break;  
 113   2              }
 114   1      }
 115          
 116          /*
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 3   

 117          *Function: set_alarm_status      
 118          *Description: è®¾ç½®æŠ¥è­¦çŠ¶æ€  ç‚¹äº®ç›¸åº”çš„ledç¯  
 119          *Calls:  
 120                  set_port_val
 121          *Data Accessed: æ—   
 122          *Data Updated: æ—     
 123          *Input: 
 124                  valï¼šæŠ¥è­¦çŠ¶æ€å€¼
 125          *Output: æ—  
 126          *Return: æ—       
 127          *Others: æ—   
 128          */
 129          void set_alarm_status(u8 *val)
 130          {
 131   1              if (val[0] == 1)
 132   1              {
 133   2                      set_port_val(LED_1, 0); 
 134   2                      set_port_val(ALARM_OUT1, 1);
 135   2              }
 136   1              else
 137   1              {               
 138   2                      set_port_val(LED_1, 1);
 139   2                      set_port_val(ALARM_OUT1, 0);
 140   2              }
 141   1              
 142   1              if (val[1] == 1)
 143   1              {               
 144   2                      set_port_val(LED_2, 0);
 145   2                      set_port_val(ALARM_OUT2, 1);
 146   2              }
 147   1              else
 148   1              {               
 149   2                      set_port_val(LED_2, 1);
 150   2                      set_port_val(ALARM_OUT2, 0);
 151   2              }
 152   1              
 153   1              if (val[2] == 1)
 154   1              {
 155   2                      set_port_val(LED_3, 0);
 156   2                      set_port_val(ALARM_OUT3, 1);
 157   2              }
 158   1              else
 159   1              {
 160   2                      set_port_val(LED_3, 1);
 161   2                      set_port_val(ALARM_OUT3, 0);
 162   2              }
 163   1              
 164   1              if (val[3] == 1)
 165   1              {
 166   2                      set_port_val(LED_4, 0);
 167   2                      set_port_val(ALARM_OUT4, 1);
 168   2              }
 169   1              else
 170   1              {
 171   2                      set_port_val(LED_4, 1);
 172   2                      set_port_val(ALARM_OUT4, 0);
 173   2              }
 174   1      }
 175          
 176          
 177          /*
 178          *Function: check_is_frist_lamp_on      
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 4   

 179          *Description: æ£€æµ‹è·¯ç¯æ˜¯å¦æ˜¯ç¬¬ä¸€å·¥ä½œ  
 180          *Calls:  
 181                  ee2_read_data
 182          *Data Accessed: æ—   
 183          *Data Updated: æ—     
 184          *Input: 
 185                  channelï¼šé€šé“å·
 186          *Output: æ—  
 187          *Return: TRUEç¬¬ä¸€ä¸Šç”µ  FALSEä¸æ˜¯ç¬¬ä¸€æ¬¡ä¸Šç”µ     
 188          *Others: æ—   
 189          */
 190          bool check_is_frist_lamp_on(u8 channel)
 191          {
 192   1              u8 i = 0;
 193   1              u8 tmp[3] = {0};
 194   1              
 195   1              ee2_read_data(channel, tmp);    // è¯»å–é€šé“çš„ç”µæµåŸºæ•°å€¼
 196   1              
 197   1              for (i=0; i<3; i++)
 198   1              {
 199   2                      if (tmp[i] != 0xFF)
 200   2                      {
 201   3                              return FALSE;
 202   3                      }
 203   2              }
 204   1              
 205   1              return TRUE;
 206   1      }
 207          
 208          /*
 209          *Function: frist_lamp_on_hander      
 210          *Description: è·¯ç¯ç¬¬ä¸€ä¸Šç”µå¤„ç†
 211          *Calls:  
 212                  rn8209_get_curr
 213          *Data Accessed: 
 214                  g_queue
 215          *Data Updated: 
 216                  g_queue
 217          *Input: 
 218                  channelï¼šé€šé“å·
 219          *Output: æ—  
 220          *Return: æ—       
 221          *Others: æ—   
 222          */
 223          void frist_lamp_on_hander(u8 channel)
 224          {
 225   1              u8 ret = 0, i = 0, tmp[3] = {0};
 226   1              u32 curr_total = 0, curr_average = 0, curr_tmp = 0;
 227   1              u32 curr[10] = {0};
 228   1              
 229   1              curr_tmp = rn8209_get_curr();
 230   1      
 231   1              ret = queue_is_full(&g_queue[channel]);
 232   1              if (ret == FALSE)       // é˜Ÿåˆ—ä¸æ»¡
 233   1              {
 234   2                      queue_en(&g_queue[channel], curr_tmp);
 235   2              }
 236   1              
 237   1              ret = queue_is_full(&g_queue[channel]);
 238   1              if (ret == TRUE)                        // é˜Ÿåˆ—æ»¡
 239   1              {
 240   2                      queue_traverse(&g_queue[channel], curr);
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 5   

 241   2                      for (i=0; i<10; i++)
 242   2                      {
 243   3                              curr_total += curr[i];          // è®¡ç®—é‡‡é›†10æ¬¡ç”µæµå€¼å¾—å’Œ
 244   3                      }
 245   2                      
 246   2                      curr_average = curr_total / 10;
 247   2                      curr_average = curr_average * 95 / 100; 
 248   2                      if (curr_tmp < curr_average)    //  
 249   2                      {
 250   3                              tmp[0] = curr[10]>>16;
 251   3                              tmp[1] = curr[10]>>8;
 252   3                              tmp[2] = curr[10]&0xFF; 
 253   3                              ee2_write_data(channel, tmp);
 254   3      
 255   3                      }
 256   2                      else
 257   2                      {
 258   3                              queue_de(&g_queue[channel]); 
 259   3                      }
 260   2              }
 261   1      }
 262          
 263          
 264          /*
 265          *Function: read_lamp_work_curr_base      
 266          *Description: è¯»å–è·¯ç¯æ²¡æœ‰è¢«ç›—çš„æ—¶å€™çš„ç”µæµåŸºæ•°å€¼  
 267          *Calls:  
 268                  ee2_read_data
 269          *Data Accessed: æ—   
 270          *Data Updated: æ—     
 271          *Input: 
 272                  channelï¼šé€šé“å·
 273          *Output: æ—  
 274          *Return: æ—       
 275          *Others: æ—   
 276          */
 277          u32 read_lamp_work_curr_base(u8 channel)
 278          {
 279   1              u8 tmp[3] = {0};
 280   1              u32 curr = 0;
 281   1              
 282   1              ee2_read_data(channel, tmp);
 283   1              
 284   1              curr = tmp[0];
 285   1              curr = (curr<<8) + tmp[1];
 286   1              curr = (curr<<8) + tmp[2];
 287   1              
 288   1              return curr;
 289   1      }
 290          
 291          /*
 292          *Function: write_lamp_work_curr_base      
 293          *Description: è®°å½•è·¯ç¯å·¥ä½œçŠ¶æ€ä¸‹çš„ç”µæµå€¼ 
 294          *Calls:  
 295                  rn8209_get_curr
 296          *Data Accessed: æ—   
 297          *Data Updated: æ—     
 298          *Input: 
 299                  channelï¼šé€šé“å·
 300          *Output: æ—  
 301          *Return: æ—       
 302          *Others: æ—   
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 6   

 303          */
 304          void write_lamp_work_curr_base(u8 channel)
 305          {
 306   1              u32 tmp_curr = 0, curr = 0, curr_total = 0;
 307   1              u8 i = 0, tmp[3] = {0};
 308   1              
 309   1              for (i=0; i<10; i++)
 310   1              {
 311   2                      tmp_curr = rn8209_get_curr();   // è¿ç»­é‡‡é›†ç”µæµå€¼
 312   2                      delay_1ms(2);
 313   2                      curr_total += tmp_curr;
 314   2              }
 315   1              
 316   1              curr = curr_total / 10;
 317   1              tmp[0] = curr>>16;
 318   1              tmp[1] = curr>>8;
 319   1              tmp[2] = curr&0xFF;     
 320   1              
 321   1              ee1_write_data(tmp);
 322   1      }
 323          
 324          
 325          /*
 326          *Function: get_lamp_work_status      
 327          *Description: è·å–è·¯ç¯å·¥ä½œçŠ¶æ€  
 328          *Calls:  
 329                  rn8209_get_vol
 330          *Data Accessed: æ—   
 331          *Data Updated: æ—     
 332          *Input: æ— 
 333          *Output: æ—  
 334          *Return: 0è¡¨ç¤ºå…³ç¯  1è¡¨ç¤ºå¼€ç¯     
 335          *Others: æ—   
 336          */
 337          u8 get_lamp_work_status(void)
 338          {
 339   1              u8 status = 0, i = 0, cnt = 0;
 340   1              u16 vol_val = 0; 
 341   1      
 342   1              for (i=0; i<10; i++)
 343   1              {
 344   2                      vol_val = rn8209_get_vol();
 345   2                      delay_1ms(2);
 346   2                      cnt++;
 347   2                      
 348   2                      if (vol_val < 100)      // è·¯ç¯æœ‰ç”µæ— ç”µæ£€æµ‹
 349   2                      {       
 350   3                              if (cnt > 8)
 351   3                              {
 352   4                                      cnt = 0;
 353   4                                      status = 0;      //  road lamp no run
 354   4                              }               
 355   3                      }
 356   2                      else
 357   2                      {
 358   3                              cnt = 0;
 359   3                              status = 1;     // road lamp run
 360   3                      }
 361   2              }
 362   1              
 363   1              return status;
 364   1      }
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 7   

 365          
 366          
 367          
 368          
 369          
 370          void unusual_curr(u8 channel)
 371          {
 372   1              u32 i = 0, cnt = 0;
 373   1              for (i=0; i<10; i++)
 374   1              {
 375   2                      g_unusual_curr[channel] = rn8209_get_curr();
 376   2      
 377   2                      if (g_unusual_curr[channel] < 0x400)
 378   2                      {
 379   3                              cnt++;
 380   3                              if (cnt > 8)
 381   3                              {               
 382   4                                      cnt = 0;
 383   4                                      g_unusual_flag[channel] = 1;
 384   4                                      
 385   4                                      TX1_write2buff(0x33);
 386   4                                      TX1_write2buff(channel);
 387   4                              }
 388   3                      }
 389   2                      else
 390   2                      {
 391   3                              cnt = 0;
 392   3                              g_unusual_flag[channel] = 0;
 393   3                              TX1_write2buff(0x22);
 394   3                      }
 395   2              }
 396   1      }
 397          
 398          
 399          /*
 400          *Function: get_lamp_on_alarm_status      
 401          *Description: è·å–è·¯ç¯å·¥ä½œçš„æ—¶å€™çš„æŠ¥è­¦çŠ¶æ€  
 402          *Calls:  
 403                  set_port_val
 404          *Data Accessed: 
 405                  curr_old
 406                  curr_tmp
 407                  curr_new
 408                  cnt
 409          *Data Updated:
 410                  curr_old
 411                  curr_tmp
 412                  curr_new
 413          *Input: 
 414                  valï¼šæŠ¥è­¦çŠ¶æ€å€¼
 415          *Output: æ—  
 416          *Return: æ—       
 417          *Others: æ—   
 418          */
 419          void get_lamp_on_alarm_status(u8 channel)
 420          {
 421   1              u8 switch_val = 0, i = 0;
 422   1              u32 tmp = 0, cnt = 0;   
 423   1              
 424   1              switch_val = get_switch_2_val();                // æ‹¨ç å¼€å…³ æŠ¥è­¦ç­‰çº§è®¾ç½®
 425   1              
 426   1              if (g_alarm_signal[channel] == 1)
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 8   

 427   1              {
 428   2                      TX1_write2buff(channel);
 429   2                      TX1_write2buff(0xBB);
 430   2              }
 431   1              else
 432   1              {
 433   2              
 434   2                      TX1_write2buff(0x11);
 435   2                      TX1_write2buff(channel);
 436   2                      
 437   2                      g_curr_tmp[channel] = g_curr_old[channel] * 95 / 100;
 438   2                      
 439   2                      tmp = rn8209_get_curr();
 440   2                      
 441   2                      g_curr_new[channel] = tmp * (70 + switch_val * 10) / 100;
 442   2                      
 443   2                      if(g_curr_new[channel] >= g_curr_old[channel])          // é‡‡é›†åˆ°çš„æ–°å€¼å¤§äºè€å€¼ 
 444   2                      {
 445   3                              g_curr_old[channel] = g_curr_new[channel];
 446   3                              
 447   3                              if(0x1 == work_mode)
 448   3                              {
 449   4                                      time_lamp_on_checking_sec[channel] = 10;
 450   4                              }
 451   3                              else
 452   3                              {
 453   4                                      time_lamp_on_checking_sec[channel] = 60;                // 60ç§’
 454   4                              }
 455   3                              g_alarm_signal[channel] = 0;
 456   3                      }
 457   2                      else if (g_curr_new[channel] > g_curr_tmp[channel]) // é‡‡é›†åˆ°çš„æ–°å€¼å°äºè€å€¼å¾—95%
 458   2                      {
 459   3                              g_curr_old[channel] = g_curr_new[channel];
 460   3                              
 461   3                              if(0x1 == work_mode)
 462   3                              {
 463   4                                      time_lamp_on_checking_sec[channel] = 10;
 464   4                              }
 465   3                              else
 466   3                              {
 467   4                                      time_lamp_on_checking_sec[channel] = 60;                // 60ç§’
 468   4                              }
 469   3                              g_alarm_signal[channel] = 0;
 470   3                      }
 471   2                      else if (g_curr_tmp[channel] - g_curr_new[channel] > 0xA00)                                     // é‡‡é›†åˆ°çš„æ–°å€¼å°äºè¾ƒå°  æµ‹è®
             -¤ä¸ºæŠ¥è­¦        
 472   2                      {
 473   3                              TX1_write2buff(0x55);
 474   3                              if (time_lamp_on_checking_sec[channel] == 0)            // è¿ç»­ç›‘æµ‹ä¸€åˆ†é’Ÿ
 475   3                              {
 476   4                                      if(0x1 == work_mode)
 477   4                                      {
 478   5                                              time_lamp_on_checking_sec[channel] = 10;
 479   5                                      }
 480   4                                      else
 481   4                                      {
 482   5                                              time_lamp_on_checking_sec[channel] = 60;                // 60ç§’
 483   5                                      }
 484   4                              
 485   4                                      g_alarm_signal[channel] = 1;
 486   4                                      
 487   4                              }       
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 9   

 488   3                              
 489   3                      }
 490   2                      
 491   2              }
 492   1      }
 493          
 494          /*
 495          *Function: get_lamp_switch_alarm_status      
 496          *Description: ä»æ— ç”µåˆ‡æ¢åˆ°æ— ç”µæ—¶ ä¼šæœ‰ç”µæµå˜åŒ–ï¼Œé€šè¿‡æœ¬å‡½æ•°æ£€æµ‹æŠ¥è­¦çŠ¶æ€  
 497          *Calls:  
 498                  read_lamp_work_curr_base
 499                  rn8209_get_curr
 500          *Data Accessed: æ—   
 501          *Data Updated: æ—     
 502          *Input: 
 503                  channelï¼šé€šé“å·
 504          *Output: æ—  
 505          *Return: æŠ¥è­¦çŠ¶æ€   0ä¸æŠ¥è­¦ 1æŠ¥è­¦     
 506          *Others: æ—   
 507          */
 508          u8 get_lamp_switch_alarm_status(u8 channel)
 509          {
 510   1              u32 curr_base = 0, cnt = 0, tmp = 0;
 511   1              u8 status = 0, i = 0;
 512   1              
 513   1              curr_base = read_lamp_work_curr_base(channel);  // è¯»å– ç”µæµåŸºæ•°å€¼
 514   1              
 515   1              curr_base = curr_base * 90 / 100;                       // 
 516   1              for (i=0; i<10; i++)
 517   1              {
 518   2                      tmp = rn8209_get_curr();
 519   2                      delay_1ms(2);
 520   2                      if (tmp < curr_base)
 521   2                      {
 522   3                              cnt++;
 523   3                              if (cnt > 8)
 524   3                              {
 525   4                                      cnt = 0;                                
 526   4                                      status = 1;
 527   4                              }
 528   3                      }
 529   2                      else
 530   2                      {
 531   3                              cnt = 0;
 532   3                      }
 533   2              }
 534   1              
 535   1              return status;
 536   1      }
 537          
 538          /*
 539          *Function: get_lamp_off_alarm_status      
 540          *Description: è·å–è·¯ç¯ä¸å·¥ä½œæ—¶æŠ¥è­¦çŠ¶æ€  
 541          *Calls:  
 542                  set_port_val
 543          *Data Accessed: æ—   
 544          *Data Updated: æ—     
 545          *Input: 
 546                  ad_to_vol
 547          *Output: æ—  
 548          *Return: æ—       
 549          *Others: æ—   
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 10  

 550          */
 551          void get_lamp_off_alarm_status(u8 channel)
 552          {
 553   1              float vol_val = 0, vol_base = 0;
 554   1              u16 ad_val = 0;
 555   1              
 556   1              ad_val = Get_ADC10bitResult(3+channel); 
 557   1              vol_val = ad_to_vol(ad_val);
 558   1              
 559   1              if (vol_val > 1.4)
 560   1              {                       
 561   2                      if (time_lamp_off_checking_sec[channel] == 0)           //æ— ç”µæ£€æµ‹æ—¶é—´
 562   2                      {       
 563   3                              if(0x1 == work_mode)
 564   3                              {
 565   4                                      time_lamp_off_checking_sec[channel] = 10;       // 10 ç§’é’Ÿ
 566   4                              }
 567   3                              else
 568   3                              {
 569   4                                      time_lamp_off_checking_sec[channel] = 60;       // 60 ç§’é’Ÿ
 570   4                              }               
 571   3                              
 572   3                              g_alarm_signal[channel] = 1;
 573   3                      }       
 574   2              }
 575   1              else
 576   1              {
 577   2              
 578   2                      if(0x1 == work_mode)
 579   2                      {
 580   3                              time_lamp_off_checking_sec[channel] = 10;       // 10 ç§’é’Ÿ
 581   3                      }
 582   2                      else
 583   2                      {
 584   3                              time_lamp_off_checking_sec[channel] = 60;       // 60 ç§’é’Ÿ
 585   3                      }       
 586   2                      
 587   2                      g_alarm_signal[channel] = 0;
 588   2              }
 589   1      }
 590          
 591          
 592          /*
 593          *Function: set_alarm_status      
 594          *Description: è®¾ç½®æŠ¥è­¦çŠ¶æ€  ç‚¹äº®ç›¸åº”çš„ledç¯  
 595          *Calls:  
 596                  set_port_val
 597          *Data Accessed: æ—   
 598          *Data Updated: æ—     
 599          *Input: 
 600                  valï¼šæŠ¥è­¦çŠ¶æ€å€¼
 601          *Output: æ—  
 602          *Return: æ—       
 603          *Others: æ—   
 604          */
 605          void app(u8 channel)
 606          {               
 607   1      
 608   1              g_power_on_flag[channel] = check_is_frist_lamp_on(channel);     
 609   1                      
 610   1              // æ£€æµ‹æ˜¯å¦æœ‰ç”µ   
 611   1              g_status_old[channel] = g_status_new[channel];          
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 11  

 612   1              g_status_new[channel] = get_lamp_work_status();
 613   1              
 614   1              if (g_status_new[channel] != g_status_old[channel])
 615   1              {
 616   2                      if(g_status_new[channel] == 1)          // ä»æ— ç”µåˆ‡æ¢åˆ°æœ‰ç”µ
 617   2                      {       
 618   3                              if (0x1 == work_mode)
 619   3                              {
 620   4                                      time_lamp_on_sec[channel] = 10; // æµ‹è¯•æ¨¡å¼
 621   4                              }
 622   3                              else
 623   3                              {
 624   4                                      time_lamp_on_sec[channel] = 60;                 // 1åˆ†é’Ÿ
 625   4                              }
 626   3                              TX1_write2buff(0xA1);
 627   3                              g_curr_tmp[channel] = 0;
 628   3                              g_curr_new[channel] = 0;
 629   3                              g_curr_old[channel] = 0;
 630   3                      }
 631   2                      else                                                            // ä»æœ‰ç”µåˆ‡æ¢åˆ°æ— ç”µ
 632   2                      {               
 633   3                              if (0x1 == work_mode)
 634   3                              {
 635   4                                      time_lamp_off_sec[channel] = 10;
 636   4                              }
 637   3                              else
 638   3                              {
 639   4                                      time_lamp_off_sec[channel] = 60;        // 30ç§’
 640   4                              }       
 641   3                              TX1_write2buff(0xA2);
 642   3                      }       
 643   2              }
 644   1              
 645   1              // æœ‰ç”µæ£€æµ‹æŠ¥è­¦
 646   1              if (g_status_new[channel] == 1)         
 647   1              {               
 648   2                      if (time_lamp_on_sec[channel] == 0)  // çŠ¶æ€åˆ‡æ¢ç­‰å¾…æ—¶é—´åˆ°
 649   2                      {
 650   3                              get_lamp_on_alarm_status(channel);      // è·å–æœ‰ç”µæŠ¥è­¦çŠ¶æ€
 651   3                      }
 652   2              }               
 653   1              else                                                    // æ— ç”µæ£€æµ‹æŠ¥è­¦
 654   1              {
 655   2                      if (time_lamp_off_sec[channel] == 0)    // çŠ¶æ€åˆ‡æ¢ç­‰å¾…æ—¶é—´åˆ°
 656   2                      {                       
 657   3                              get_lamp_off_alarm_status(channel);
 658   3                      }
 659   2              }               
 660   1      }
 661          
 662          
 663          
 664          
 665          
 666          
 667          
 668          
 669          
 670          
 671          
 672          
 673          
C51 COMPILER V9.00   ADCHL                                                                 11/18/2015 10:20:08 PAGE 12  

 674          
 675          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3376    ----
   CONSTANT SIZE    =     72    ----
   XDATA SIZE       =    109     164
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
